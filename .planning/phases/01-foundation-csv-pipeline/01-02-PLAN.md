---
phase: 01-foundation-csv-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/csvparse/types.go
  - internal/csvparse/parser.go
  - internal/server/server.go
  - web/static/js/app.js
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "用户可以通过文件选择器上传 CSV 文件，系统接受并处理"
    - "系统自动检测 GBK 和 UTF-8 编码，无需用户干预即可正确解析"
    - "系统识别禅道 CSV 的 36 个中文表头并映射到内部字段"
    - "缺少必填列时显示中文错误提示，指明缺少哪些列"
    - "数据格式错误时显示中文错误提示，指明哪行哪个字段有问题"
    - "处理 5 万行 CSV（约 1.7MB）无明显卡顿"
  artifacts:
    - path: "internal/csvparse/types.go"
      provides: "Bug 结构体、中文表头到字段的映射表、必填字段列表"
      exports: ["Bug", "HeaderMap", "RequiredHeaders"]
      min_lines: 60
    - path: "internal/csvparse/parser.go"
      provides: "CSV 解析器：编码检测、GBK→UTF-8 转换、CSV 读取、表头映射、数据验证"
      exports: ["Parse", "ParseResult"]
      min_lines: 100
    - path: "internal/server/server.go"
      provides: "新增 POST /api/upload 路由，处理 multipart 文件上传"
      contains: "/api/upload"
    - path: "web/static/js/app.js"
      provides: "前端上传逻辑：FormData 提交、进度反馈、错误/成功显示"
      contains: "fetch.*api/upload"
  key_links:
    - from: "web/static/js/app.js"
      to: "/api/upload"
      via: "fetch POST multipart/form-data 提交 CSV 文件"
      pattern: "fetch.*api/upload"
    - from: "internal/server/server.go"
      to: "csvparse.Parse()"
      via: "upload handler 读取 multipart 文件后调用解析器"
      pattern: "csvparse\\.Parse"
    - from: "internal/csvparse/parser.go"
      to: "golang.org/x/text/encoding/simplifiedchinese"
      via: "GBK 编码检测与转换"
      pattern: "simplifiedchinese\\.GBK"
    - from: "internal/csvparse/parser.go"
      to: "internal/csvparse/types.go"
      via: "使用 HeaderMap 映射表头、用 Bug 结构体存储解析结果"
      pattern: "HeaderMap|Bug\\{"
    - from: "web/static/js/app.js"
      to: "#upload-status"
      via: "显示解析成功摘要或中文错误信息"
      pattern: "upload-status"
---

<objective>
实现 CSV 上传管线：文件上传端点、GBK/UTF-8 编码自动检测、禅道表头识别与映射、数据验证与中文错误提示、前端上传交互完整闭环。

Purpose: 让用户能够将禅道导出的 CSV 文件导入系统，数据被正确解析并准备好供后续分析模块使用。这是所有分析功能的数据基础。
Output: 完整的 CSV 导入流程 — 从前端选择文件到后端解析验证，成功后存储在内存中供后续 API 使用。
</objective>

<execution_context>
@C:/Users/zhang/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/zhang/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@需求与设计文档.md
@2225.csv

Prior plan context (if needed):
@.planning/phases/01-foundation-csv-pipeline/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: CSV 数据模型与解析器 — Bug 结构体、编码检测、表头映射、数据验证</name>
  <files>internal/csvparse/types.go, internal/csvparse/parser.go, go.mod, go.sum</files>
  <action>
1. 添加依赖：`go get golang.org/x/text`（提供 GBK→UTF-8 编码转换）

2. 创建 `internal/csvparse/types.go`：
   - **Bug 结构体**（所有字段用 string 类型，日期字段后续按需解析为 time.Time）：
     ```
     type Bug struct {
         ID              string    // Bug编号
         Product         string    // 所属产品
         Module          string    // 所属模块
         Title           string    // Bug标题
         Severity        string    // 严重程度 (1-4)
         Priority        string    // 优先级
         BugType         string    // Bug类型
         Status          string    // Bug状态 (激活/已解决/已关闭)
         Creator         string    // 由谁创建
         CreatedDate     string    // 创建日期
         Assignee        string    // 指派给
         AssignedDate    string    // 指派日期
         Resolver        string    // 解决者
         Resolution      string    // 解决方案
         ResolvedDate    string    // 解决日期
         Closer          string    // 由谁关闭
         ClosedDate      string    // 关闭日期
         ActivationCount string    // 激活次数
         Deadline        string    // 截止日期
         AffectedVersion string    // 影响版本
         ResolvedVersion string    // 解决版本
         Keywords        string    // 关键词
     }
     ```
   - **HeaderMap**：`map[string]string` 映射中文表头到 Bug 字段名
     ```
     var HeaderMap = map[string]string{
         "Bug编号":    "ID",
         "所属产品":   "Product",
         "所属模块":   "Module",
         "Bug标题":    "Title",
         "严重程度":   "Severity",
         "优先级":     "Priority",
         "Bug类型":    "BugType",
         "Bug状态":    "Status",
         "由谁创建":   "Creator",
         "创建日期":   "CreatedDate",
         "指派给":     "Assignee",
         "指派日期":   "AssignedDate",
         "解决者":     "Resolver",
         "解决方案":   "Resolution",
         "解决日期":   "ResolvedDate",
         "由谁关闭":   "Closer",
         "关闭日期":   "ClosedDate",
         "激活次数":   "ActivationCount",
         "截止日期":   "Deadline",
         "影响版本":   "AffectedVersion",
         "解决版本":   "ResolvedVersion",
         "关键词":     "Keywords",
     }
     ```
   - **RequiredHeaders**：`[]string{"Bug编号", "Bug标题", "严重程度", "Bug状态", "由谁创建", "创建日期", "指派给"}`
   - **ParseResult 结构体**：
     ```
     type ParseResult struct {
         Bugs       []Bug    // 解析出的 Bug 列表
         TotalRows  int      // 总行数
         Warnings   []string // 非致命警告（如某些行有空字段）
     }
     ```

3. 创建 `internal/csvparse/parser.go`：
   - **Parse(r io.Reader) (*ParseResult, error)** — 主入口函数：
     a. 将 reader 内容读入 []byte（一次性读取，因为需要编码检测）
     b. 调用 `detectAndConvert(data)` 获取 UTF-8 字节流
     c. 用 `encoding/csv.NewReader()` 读取所有行
     d. 调用 `mapHeaders(headerRow)` 建立列索引→字段名映射
     e. 调用 `validateHeaders(headerMapping)` 检查必填列
     f. 逐行调用 `rowToBug(row, headerMapping)` 转为 Bug 结构体
     g. 收集警告（跳过完全空行，记录部分字段缺失的行）
     h. 返回 ParseResult

   - **detectAndConvert(data []byte) ([]byte, error)** — 编码检测与转换：
     a. 先尝试 UTF-8 检测：`utf8.Valid(data)` — 如果全部有效则直接返回
     b. 检查 UTF-8 BOM (0xEF 0xBB 0xBF)，有则去除 BOM 后返回
     c. 否则假定 GBK，使用 `simplifiedchinese.GBK.NewDecoder().Bytes(data)` 转换
     d. 转换失败则返回错误：`"文件编码无法识别，请确认文件为 GBK 或 UTF-8 编码"`

   - **mapHeaders(row []string) map[int]string** — 表头映射：
     a. 遍历 CSV 第一行，去除每个单元格的 BOM 和首尾空白
     b. 在 HeaderMap 中查找，找到则记录 `columnIndex → fieldName`
     c. 未识别的列忽略（不报错，禅道可能有额外列）

   - **validateHeaders(mapping map[int]string) error** — 验证必填列：
     a. 检查 RequiredHeaders 中每个表头是否都在 mapping 的值中
     b. 缺少的列收集到列表
     c. 有缺失则返回错误：`"CSV 缺少必填列：Bug编号, 严重程度"` （列出所有缺失列名）

   - **rowToBug(row []string, mapping map[int]string) Bug** — 行转结构体：
     a. 遍历 mapping，将 row[colIdx] 赋值到 Bug 对应字段
     b. 字符串字段 `strings.TrimSpace`
     c. 注意：CSV 行列数可能少于表头列数（禅道导出偶有此情况），做越界检查

   - **性能要点**：
     - 一次性读入内存进行编码检测（1.7MB 文件完全可接受）
     - `csv.NewReader` 设置 `LazyQuotes = true`（禅道 CSV 有不规范引号）
     - `csv.NewReader` 设置 `FieldsPerRecord = -1`（允许列数不一致）
     - 预分配 Bug 切片容量：`make([]Bug, 0, totalRows)`

4. 运行 `go mod tidy` 确保依赖正确
  </action>
  <verify>
- `go vet ./...` 无警告
- `go build ./...` 编译成功
- 手动测试建议：在 parser.go 同目录写一个简单的 _test.go 或在 main 中临时测试解析 2225.csv，确认：
  - 能正确检测编码并转为 UTF-8
  - 表头映射成功（输出 mapping 确认）
  - 解析出的 Bug 数量约 51000 条
  - 第一条 Bug 的 ID、标题、状态等字段非空
  </verify>
  <done>
CSV 解析器能正确处理 GBK/UTF-8 编码，识别禅道 36 列中文表头，将数据映射为 Bug 结构体切片。缺少必填列时返回明确中文错误。5 万行数据可快速解析。
  </done>
</task>

<task type="auto">
  <name>Task 2: 上传端点与前端集成 — HTTP handler、内存存储、上传交互、错误/成功反馈</name>
  <files>internal/server/server.go, web/static/js/app.js</files>
  <action>
1. 更新 `internal/server/server.go`：
   - 在 server 包中添加一个包级或结构体级变量存储解析结果：
     ```
     type AppState struct {
         mu     sync.RWMutex
         Result *csvparse.ParseResult
     }
     ```
   - 修改 `New()` 函数签名为 `New(staticFS fs.FS, state *AppState) http.Handler`
   - 注册新路由 `POST /api/upload`（Go 1.22+ 用 `mux.HandleFunc("POST /api/upload", ...)`，否则在 handler 内检查 method）
   - **handleUpload handler**：
     a. 限制上传大小：`r.Body = http.MaxBytesReader(w, r.Body, 100<<20)` (100MB)
     b. `r.ParseMultipartForm(32 << 20)` 解析表单
     c. 获取文件：`file, header, err := r.FormFile("file")`
     d. 校验文件名后缀为 .csv，否则返回 JSON 错误：`{"error": "请上传 CSV 文件"}`
     e. 调用 `csvparse.Parse(file)` 解析
     f. 如果解析失败，返回 JSON：`{"error": "具体中文错误信息"}`
     g. 解析成功，将结果存入 `state.Result`（加锁）
     h. 返回 JSON 摘要：
        ```json
        {
          "success": true,
          "summary": {
            "totalBugs": 51234,
            "columns": ["Bug编号", "所属产品", ...],
            "warnings": ["第 125 行: 指派给 字段为空", ...],
            "sampleBug": { "id": "23757", "title": "...", "status": "激活" }
          }
        }
        ```
   - 所有 API 响应设置 `Content-Type: application/json; charset=utf-8`
   - 错误响应使用合适的 HTTP 状态码：400（客户端错误）、500（服务端错误）

   - 同时注册 `GET /api/data` 端点（为 Phase 2 预留）：
     a. 如果 `state.Result` 为 nil，返回 `{"error": "请先上传 CSV 文件"}`
     b. 否则返回完整的 `ParseResult` JSON

2. 更新 `main.go`：
   - 创建 `state := &server.AppState{}`
   - 传入 `server.New(staticFS, state)`

3. 更新 `web/static/js/app.js`：
   - **uploadCSV(file) 函数**完整实现：
     a. 创建 FormData，append file 字段
     b. 显示上传中状态：`showStatus("正在解析 CSV 文件...", "info")`
     c. `fetch("/api/upload", { method: "POST", body: formData })`
     d. 检查响应状态码
     e. 解析 JSON 响应
     f. 成功时：
        - `showStatus("解析成功！共 N 条 Bug 记录", "success")`
        - 如有 warnings，在状态区下方追加警告列表
        - 调用 `showDashboard()` 显示仪表盘区域
        - 将摘要数据存储在 `window.BugAnalysis.data` 供后续图表使用
     g. 失败时：
        - `showStatus(response.error, "error")`（直接显示服务端返回的中文错误）
        - 不切换到仪表盘视图
   - **错误处理增强**：
     - 网络错误：`showStatus("网络错误，请检查服务是否运行", "error")`
     - 文件过大提示：检查 file.size，超过 100MB 提示 "文件过大（最大 100MB）"
   - **上传按钮状态**：上传期间禁用按钮防止重复提交，完成后恢复

4. 使用样本数据测试完整流程：
   - `go build -o go-bug-analysis.exe . && ./go-bug-analysis.exe`
   - 在浏览器中选择 `2225.csv`（工作目录下的样本文件）
   - 验证上传成功，显示正确的 Bug 总数
  </action>
  <verify>
- `go build -o go-bug-analysis.exe .` 编译成功
- `go vet ./...` 无警告
- 运行后通过浏览器上传 2225.csv：
  - 上传过程中显示 "正在解析 CSV 文件..."
  - 解析成功后显示 "解析成功！共 ~51000 条 Bug 记录"
  - 页面切换到仪表盘视图
- 上传一个非 CSV 文件，显示 "请上传 CSV 文件" 错误
- 上传一个缺少必填列的 CSV（手动创建测试文件），显示 "CSV 缺少必填列：XXX" 错误
- `curl -X POST http://localhost:18088/api/upload -F "file=@2225.csv"` 返回正确 JSON
  </verify>
  <done>
完整的 CSV 上传流程可用：用户在浏览器选择文件 → 后端自动检测编码并解析 → 成功时显示摘要切换到仪表盘视图，失败时显示中文错误信息。5 万行数据处理流畅。数据存储在内存中供后续分析 API 使用。
  </done>
</task>

</tasks>

<verification>
1. `go build -o go-bug-analysis.exe .` — 编译成功
2. `go vet ./...` — 无警告
3. 启动后上传 2225.csv（GBK 编码，~51000 行）：
   - 编码自动检测正确（无乱码）
   - 解析成功，Bug 总数正确
   - 页面显示成功摘要
4. 上传 UTF-8 编码的 CSV 文件同样能正确解析
5. 上传缺少必填列的 CSV 显示中文错误 "CSV 缺少必填列：XXX"
6. 上传非 CSV 文件显示 "请上传 CSV 文件"
7. GET /api/data 在未上传时返回提示，上传后返回完整数据
</verification>

<success_criteria>
- GBK 和 UTF-8 编码的禅道 CSV 均可正确解析
- 5 万行 CSV 上传解析无明显延迟（< 3 秒）
- 前端有完整的上传交互反馈（进度、成功、错误）
- 错误信息全部为中文，明确指出问题所在
- 解析后的数据可通过 API 获取，为 Phase 2 分析做好准备
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-csv-pipeline/01-02-SUMMARY.md`
</output>
