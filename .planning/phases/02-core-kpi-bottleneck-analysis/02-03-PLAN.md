---
phase: 02-core-kpi-bottleneck-analysis
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - internal/analysis/workload.go
  - internal/analysis/types.go
  - internal/analysis/analyze.go
  - web/static/js/dashboard.js
  - web/static/index.html
  - web/static/css/style.css
autonomous: true

must_haves:
  truths:
    - "User sees currently active bug count per assignee in chart form"
    - "User sees total bug count per assignee in chart form"
  artifacts:
    - path: "internal/analysis/workload.go"
      provides: "ComputeWorkload function: per-assignee active and total counts"
      exports: ["ComputeWorkload"]
    - path: "internal/analysis/types.go"
      provides: "WorkloadData, AssigneeStats structs"
      contains: "WorkloadData"
  key_links:
    - from: "internal/analysis/analyze.go"
      to: "internal/analysis/workload.go"
      via: "Analyze() calls ComputeWorkload()"
      pattern: "ComputeWorkload"
    - from: "web/static/js/dashboard.js"
      to: "response.workload"
      via: "renderWorkload() reads workload data from API response"
      pattern: "renderWorkload"
---

<objective>
Personnel workload distribution charts

Purpose: Show per-assignee bug distribution so users can identify overloaded team members and imbalanced workload allocation. Completes the Phase 2 analysis suite.

Output: Two ECharts horizontal bar charts side by side — one showing active bugs per assignee, one showing total bugs per assignee — both sorted by count descending.
</objective>

<execution_context>
@C:/Users/zhang/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/zhang/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-kpi-bottleneck-analysis/02-01-SUMMARY.md
@.planning/phases/02-core-kpi-bottleneck-analysis/02-02-SUMMARY.md
@internal/analysis/types.go
@internal/analysis/analyze.go
@web/static/js/dashboard.js
@web/static/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend — Assignee workload computation</name>
  <files>
    internal/analysis/workload.go
    internal/analysis/types.go
    internal/analysis/analyze.go
  </files>
  <action>
**Add types to `internal/analysis/types.go`:**
```go
type WorkloadData struct {
    ByActive []AssigneeStats `json:"byActive"` // sorted descending by count
    ByTotal  []AssigneeStats `json:"byTotal"`  // sorted descending by count
}

type AssigneeStats struct {
    Name  string `json:"name"`
    Count int    `json:"count"`
}
```

Add `Workload *WorkloadData` field to `AnalysisResult` struct with json tag `"workload,omitempty"`.

**Create `internal/analysis/workload.go`:**
- `ComputeWorkload(bugs []csvparse.Bug) *WorkloadData`:
  - Build two maps: `activeCount map[string]int` and `totalCount map[string]int`.
  - Iterate all bugs:
    - assignee = bug.Assignee (trim space). If empty, use "未指派".
    - Increment totalCount[assignee].
    - If bug.Status == "激活", increment activeCount[assignee].
  - Convert maps to sorted slices:
    - `byActive`: all assignees with activeCount > 0, sorted by count descending. Use `sort.Slice`.
    - `byTotal`: all assignees with totalCount > 0, sorted by count descending.
  - Return WorkloadData.

**Update `internal/analysis/analyze.go`:**
- Add `result.Workload = ComputeWorkload(bugs)` call in the Analyze function.
  </action>
  <verify>
Run `go build ./...` — must compile.
Run `go vet ./...` — no warnings.
Start server, upload CSV, curl `/api/analysis` — response includes `workload` field with `byActive` and `byTotal` arrays, each containing name/count pairs sorted by count descending.
  </verify>
  <done>
API returns workload analysis: byActive array showing active bug count per assignee (sorted descending), byTotal array showing total bug count per assignee (sorted descending). Unassigned bugs grouped as "未指派".
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend — Workload distribution charts</name>
  <files>
    web/static/js/dashboard.js
    web/static/index.html
    web/static/css/style.css
  </files>
  <action>
**Update `web/static/index.html`:**
Add workload section AFTER the backlog table in the dashboard:

```html
<div class="chart-row" id="workload-row">
    <div class="chart-card">
        <h3 class="chart-title">当前激活 Bug 分布（按指派人）</h3>
        <div class="chart-container chart-container-dynamic" id="chart-workload-active"></div>
    </div>
    <div class="chart-card">
        <h3 class="chart-title">Bug 总量分布（按指派人）</h3>
        <div class="chart-container chart-container-dynamic" id="chart-workload-total"></div>
    </div>
</div>
```

**Update `web/static/js/dashboard.js`:**
Extend `renderDashboard()` to also call `renderWorkload(data.workload)`.

- `renderWorkload(workload)`:
  - If workload is null, return early.
  - Call renderWorkloadChart for both active and total.

- `renderWorkloadChart(containerId, data, colorStart, colorEnd)`:
  - `data` is an array of {name, count}.
  - Show top 15 assignees max (to keep chart readable). If more exist, add note "显示前15人".
  - Initialize ECharts on container.
  - Render horizontal bar chart:
    - Y-axis: assignee names (in reverse order so highest count is at top). Type: 'category'.
    - X-axis: bug count. Type: 'value'.
    - Bars with rounded corners (borderRadius: [0, 4, 4, 0]).
    - Gradient color from colorStart to colorEnd (use ECharts linear gradient).
    - Show value labels at end of each bar (position: 'right').
    - Grid: left padding enough for long Chinese names (e.g., left: '100').
  - For active chart: use warm colors (e.g., #ff7a45 to #ff4d4f).
  - For total chart: use cool colors (e.g., #1890ff to #096dd9).
  - Dynamic height: set container height based on data length: `Math.max(300, data.length * 32)` px.
    Use the `.chart-container-dynamic` class with no min-height set, and set height via JS before init.
  - Handle resize.
  - Store chart instances in module scope for cleanup.

**Update `web/static/css/style.css`:**
- `.chart-container-dynamic`: min-height auto (override the 360px default), used for dynamic-height charts.
- Ensure `.chart-row` remains responsive — on mobile (max-width: 768px), stack vertically.
  </action>
  <verify>
Start server, upload CSV. Verify:
1. Two workload charts appear below the backlog table.
2. Active bugs chart shows assignees sorted by count (highest at top).
3. Total bugs chart shows assignees sorted by count (highest at top).
4. Charts render with horizontal bars and value labels.
5. Charts resize on window resize.
6. Long assignee names don't get cut off.
7. Mobile layout stacks charts vertically.
  </verify>
  <done>
Two workload distribution charts display per-assignee bug counts. Active chart shows currently active bugs, total chart shows all bugs. Both sorted descending by count with top 15 shown. Requirements WRK-01 and WRK-02 satisfied. Phase 2 complete.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` and `go vet ./...` pass
2. Upload CSV → workload charts appear
3. Active chart shows assignees with active bug counts
4. Total chart shows assignees with total bug counts
5. Charts sorted by count descending
6. Responsive layout works on mobile
7. Full Phase 2 flow: upload CSV → all KPI cards, severity chart, fix time stats, backlog table, workload charts render correctly
</verification>

<success_criteria>
- Active bug distribution per assignee displays as horizontal bar chart
- Total bug distribution per assignee displays as horizontal bar chart
- Both charts sorted by count descending, showing top assignees
- Phase 2 feature suite complete: KPI + Severity + Age + Workload
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-kpi-bottleneck-analysis/02-03-SUMMARY.md`
</output>
